/* -----------------------------------------
             Group Number- 6
ID 2021B5A71704P Name Arushi Gulati
ID 2021B3A71260P Name Aryan Rajkumar Keshri
ID 2021B4A70887P Name Chinmay Pushkar
ID 2021B3A71102P Name Om Kotadiya Jain
ID 2021B3A71117P Name Riddhi Agarwal
ID 2021B5A70923P Name Shwetabh Niket
--------------------------------------------- */

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "first_and_follow.h"
#include "grammar.h"
#include "parser.h"
#include "parse_table.h"

// External declarations
extern int rule_cnt;

// Function declarations
void display_comment_free_code(const char* clean_file);
void parse_and_print_tree(const char* clean_file, const char* output_file);
void measure_execution_time(const char* clean_file);
void display_menu();

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s <source_file> [output_file]\n", argv[0]);
        printf("Note: output_file is required for parse tree generation (option 3)\n");
        return 1;
    }

    // Store output file name if provided
    char* output_file = NULL;
    if (argc >= 3) {
        output_file = argv[2];
    }

    // Create a clean version of the input file without comments
    char clean_file[256];
    snprintf(clean_file, sizeof(clean_file), "%s.clean", argv[1]);
    removeComments(argv[1], clean_file);

    int option = -1;
    
    // Display menu and process options in a loop
    while (option != 0) {
        display_menu();
        
        // Get user input
        printf("Enter your choice: ");
        scanf("%d", &option);
        
        switch (option) {
            case 0:
                printf("Exiting program.\n");
                break;
            case 1:
                display_comment_free_code(clean_file);
                break;
            case 2: {
                // Use the existing printTokens function
                FILE* fp = fopen(argv[1], "r");
                if (!fp) {
                    printf("Error: Could not open clean file\n");
                    break;
                }
                initLexer();
                printTokens(fp);
                fclose(fp);
                break;
            }
            case 3:
                if (output_file == NULL) {
                    printf("Error: Output file not specified. Please run the program with an output file argument.\n");
                    printf("Usage: %s <source_file> <output_file>\n", argv[0]);
                } else {
                    parse_and_print_tree(clean_file, output_file);
                }
                break;
            case 4:
                measure_execution_time(clean_file);
                break;
            default:
                printf("Invalid option. Please try again.\n");
                break;
        }
    }

    return 0;
}

void display_menu() {
    printf("\n");
    printf("0 : For exit\n");
    printf("1 : For removal of comments - print the comment free code on the console\n");
    printf("2 : For printing the token list (on the console) generated by the lexer. \n");
    printf("3 : For parsing to verify the syntactic correctness of the input source code and printing the parse tree to the specified output file. \n");
    printf("   (Note: Requires output file to be specified as second command-line argument)\n");
    printf("4 : For printing (on the console) the total time taken by our compiler\n");
    printf("\n");
}

void display_comment_free_code(const char* clean_file) {
    // Open the clean file and print its contents
    FILE* fp = fopen(clean_file, "r");
    if (!fp) {
        printf("Error: Could not open clean file\n");
        return;
    }
    
    printf("\n--- Comment-free code ---\n");
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), fp)) {
        printf("%s", buffer);
    }
    
    fclose(fp);
}

void parse_and_print_tree(const char* clean_file, const char* output_file) {
    FILE* fp = fopen(clean_file, "r");
    if (!fp) {
        printf("Error: Could not open clean file\n");
        return;
    }
    
    // Initialize grammar and parse table
    initializeHashTable();
    fill_grammar();
    compute_parse_table();
    
    // Create parse tree
    parse_tree tree = create_parse_tree(fp);
    if (tree) {
        printf("\nParse Tree created successfully.\n");
        
        // Use the output file provided as command-line argument
        printParseTree(tree, output_file);
        
        printf("Parse tree has been written to %s\n", output_file);
        
        free_parse_tree(tree);
    } else {
        printf("Failed to create parse tree\n");
    }
    
    fclose(fp);
}

void measure_execution_time(const char* clean_file) {
    clock_t start_time, end_time;
    double total_cpu_time, total_cpu_time_in_seconds;
    
    printf("\n--------------------------------------------------------------------------------------------------------\n");
    
    // Start timing
    start_time = clock();
    
    // Initialize lexer, grammar, and parse table
    initLexer();
    initializeHashTable();
    fill_grammar();
    compute_parse_table();
    
    // Open file
    FILE* fp = fopen(clean_file, "r");
    if (!fp) {
        printf("Error: Could not open clean file\n");
        return;
    }
    
    // Create parse tree
    parse_tree tree = create_parse_tree(fp);
    if (tree) {
        free_parse_tree(tree);
    }
    
    fclose(fp);
    
    // End timing
    end_time = clock();
    
    // Calculate time
    total_cpu_time = (double)(end_time - start_time);
    total_cpu_time_in_seconds = total_cpu_time / CLOCKS_PER_SEC;
    
    // Print timing results
    printf("Total CPU time: %f\n", total_cpu_time);
    printf("Total CPU time in seconds: %f\n", total_cpu_time_in_seconds);
    
    printf("--------------------------------------------------------------------------------------------------------\n");
}